# Exercise 03 - Vectorized Logistic Loss Function

|                         |                         |
| -----------------------:| ----------------------- |
|   Turning directory :   |  ex03                   |
|   Files to turn in :    |  vec_log_loss.py        |
|   Forbidden function :  |  None                   |
|   Remarks :             |  n/a                    |

Now that you understood how we can calculate the loss, you will see how to do it with vectorized operations.
The goal of this exercise is to produce the same result as ex01 but this time you will use numpy arrays.

Create a function called `vec_log_loss_` which takes four arguments: 

```python
def vec_log_loss_(y_true, y_pred, m, eps=1e-15):
```
  - y_true: a scalar value or a vector for the desired output
  - y_pred: a scalar value or a vector for the hypothesis
  - m: the length of y_true
  - eps: optional (default=1e-15)
  - returns: scalar value 


```python
import numpy as np
from sigmoid import sigmoid_
from vec_log_loss import vec_log_loss_

# Test n.1
x = 4
y_true = 1
theta = 0.5
y_pred = sigmoid_(x * theta)
m = 1   # length of y_true is 1
print(vec_log_loss_(y_true, y_pred, m))     
# 0.12692801104297152

# Test n.2
x = np.array([1, 2, 3, 4])
y_true = 0
theta = np.array([-1.5, 2.3, 1.4, 0.7])
y_pred = sigmoid_(np.dot(x, theta))
m = 1
print(vec_log_loss_(y_true, y_pred, m))     
# 10.100041078687479

# Test n.3
x_new = np.arange(1, 13).reshape((3, 4))
y_true = np.array([1, 0, 1])
theta = np.array([-1.5, 2.3, 1.4, 0.7])
y_pred = sigmoid_(np.dot(x_new, theta))
m = len(y_true)
print(vec_log_loss_(y_true, y_pred, m))     
# 7.233346147374828
```
