# Exercise 03 - Vectorized Logistic Loss Function

|                         |                         |
| -----------------------:| ----------------------- |
|   Turning directory :   |  ex03                   |
|   Files to turn in :    |  vec_log_loss.py        |
|   Forbidden function :  |  None                   |
|   Remarks :             |  n/a                    |

Now that you understood how we can calculate the loss, you will see how to do it with vectorized operations.
The goal of this exercise is to produce the same result as ex01 but this time you will use numpy arrays.

**Instruction:**

Create a function called `vec_log_loss_` which takes four arguments: 
```python
def vec_log_loss_(y_true, y_pred, m, eps=1e-15):
    """
    :param y_true: a scalar or a vector for the correct labels
    :param y_pred: a scalar or a vector for the predicted labels
    :param m: the length of y_true
    :param eps: epsilon
    :return: the log loss as a scalar
    """
```

! You might want to update your sigmoid function to work with numpy arrays !

**Output examples:**
```python
import numpy as np
from sigmoid import sigmoid_
from vec_log_loss import vec_log_loss_

# Test n.1
x = 4
y_true = 1
theta = 0.5
y_pred = sigmoid_(x * theta)
m = 1   # length of y_true is 1
print(vec_log_loss_(y_true, y_pred, m))     
# 0.12692801104297152

# Test n.2
x = np.array([1, 2, 3, 4])
y_true = 0
theta = np.array([-1.5, 2.3, 1.4, 0.7])
y_pred = sigmoid_(np.dot(x, theta))
m = 1
print(vec_log_loss_(y_true, y_pred, m))     
# 10.100041078687479

# Test n.3
x_new = np.arange(1, 13).reshape((3, 4))
y_true = np.array([1, 0, 1])
theta = np.array([-1.5, 2.3, 1.4, 0.7])
y_pred = sigmoid_(np.dot(x_new, theta))
m = len(y_true)
print(vec_log_loss_(y_true, y_pred, m))     
# 7.233346147374828
```
